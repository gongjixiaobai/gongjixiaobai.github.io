<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dockerfile最佳实践</title>
    <link href="/2022/03/08/docker-Dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/03/08/docker-Dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h5 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1.FROM"></a>1.FROM</h5><ol><li>FROM scratch #制作base image</li><li>FROM centos #使用base image</li><li>FROM ubuntu:14.04</li></ol><p><em>尽量使用官方的image作为base images</em></p><h5 id="2-LABEL"><a href="#2-LABEL" class="headerlink" title="2.LABEL"></a>2.LABEL</h5><p>LABEL maintainer &#x3D; “<a href="mailto:&#119;&#x65;&#x69;&#x6d;&#x69;&#x6e;&#x67;&#48;&#x32;&#x40;&#x6d;&#x65;&#x67;&#x76;&#105;&#x69;&#46;&#99;&#111;&#x6d;">&#119;&#x65;&#x69;&#x6d;&#x69;&#x6e;&#x67;&#48;&#x32;&#x40;&#x6d;&#x65;&#x67;&#x76;&#105;&#x69;&#46;&#99;&#111;&#x6d;</a>“</p><p>LABEL version&#x3D;”1.0”</p><p>LABEL description&#x3D;”this is description”</p><p> <em>Metadata不可少</em></p><h5 id="3-RUN"><a href="#3-RUN" class="headerlink" title="3.RUN"></a>3.RUN</h5><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">RUN yum update &amp;&amp; yum install -y vim \<br>    python-dev<br></code></pre></td></tr></table></figure><p><em>为了美观，复杂的RUN请用反斜线换行，避免无用分层，合并多条命令成一行</em></p><h5 id="4-WORKDIR"><a href="#4-WORKDIR" class="headerlink" title="4.WORKDIR"></a>4.WORKDIR</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">WORKDIR /test #如果没有会自动创建<br>WORKDIR demo<br>RUN pwd<br></code></pre></td></tr></table></figure><p><em>用WORKDIR,不要使用RUN cd,尽力使用绝对目录</em></p><h5 id="5-ADD-and-COPY"><a href="#5-ADD-and-COPY" class="headerlink" title="5.ADD and COPY"></a>5.ADD and COPY</h5><ol><li>大部分情况，copy优于ADD</li><li>ADD除了COPY还有额外功能（解压）</li><li>添加远程文件&#x2F;目录请使用curl或者wget</li></ol><h5 id="6-ENV"><a href="#6-ENV" class="headerlink" title="6.ENV"></a>6.ENV</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENV MYSQL_VERSION 5.6 #设置常量<br>RUN apt-get insatll -y mysql-server= &quot;$&#123;MYSQL_VERSION&#125;&quot; \<br>    &amp;&amp;rm -rf /var/lib/apt/lists/* #引用常量<br></code></pre></td></tr></table></figure><p><em>尽量使用ENV增加可维护性</em></p><h5 id="7-RUN-amp-CMD-amp-ENTRYPOINT"><a href="#7-RUN-amp-CMD-amp-ENTRYPOINT" class="headerlink" title="7.RUN&amp;CMD&amp;ENTRYPOINT"></a>7.RUN&amp;CMD&amp;ENTRYPOINT</h5><p>RUN：执行命令比创建新的Image Layer</p><p>CMD：设置容器启动后默认执行的命令和参数</p><p>ENTRYPOINT：设置容器启动时运行的命令</p><h5 id="8-SHELL格式和EXEC格式区别"><a href="#8-SHELL格式和EXEC格式区别" class="headerlink" title="8.SHELL格式和EXEC格式区别"></a>8.SHELL格式和EXEC格式区别</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">shell格式</span><br>RUN apt-get install -y vim<br>CMD echo &quot;docker so easy&quot;<br>ENTRYPOINT echo &quot;docker so easy&quot;<br><span class="hljs-meta">  </span><br><span class="hljs-meta">#</span><span class="language-bash">Exec格式</span><br>RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]<br>CMD [&quot;echo&quot;,&quot;docker so easy&quot;]<br>ENTRYPOINT [&quot;echo&quot;,&quot;docker so easy&quot;]<br></code></pre></td></tr></table></figure><p>通过两个dockerfile来对比</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos<br>ENV name Docker<br>ENTRYPOINT echo &quot;hello $name&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos<br>ENV name Docker<br>ENTRYPOINT [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]<br></code></pre></td></tr></table></figure><p><em>如果不加-c，运行镜像后输出echo hello $name</em></p><h5 id="9-CMD和ENTRYPOINT注意点"><a href="#9-CMD和ENTRYPOINT注意点" class="headerlink" title="9.CMD和ENTRYPOINT注意点"></a>9.CMD和ENTRYPOINT注意点</h5><h6 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h6><ol><li>容器启动时默认执行的命令</li><li>如果docker run指定了其他命令，CMD命令会忽略</li><li>如果定义了多个CMD，只有最后一个会执行</li></ol><h6 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h6><ol><li>让容器以应用程序或者服务的形式运行</li><li>不会被忽略，一定会执行</li><li>最佳实践：写一个shell脚本作为entrypoint</li></ol>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile</title>
    <link href="/2022/03/08/docker-Dockerfile/"/>
    <url>/2022/03/08/docker-Dockerfile/</url>
    
    <content type="html"><![CDATA[<h5 id="Dockerfile说明："><a href="#Dockerfile说明：" class="headerlink" title="Dockerfile说明："></a>Dockerfile说明：</h5><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明</p><p>FROM：基础镜像，当前新镜像是基于哪个镜像的</p><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p><p>RUN：容器构建时需要运行的命令</p><p>EXPOSE：当前容器对外暴露出的端口</p><p>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><p>ENV：用来在构建镜像过程中设置环境变量</p><p>ADD：将宿主机目录下的文件拷贝进镜像且 ADD 命令会自动处理 URL 和解压 tar 压缩包</p><p>COPY：类似 ADD，拷贝文件和目录到镜像中。（COPY src dest 或 COPY [“src”,”dest”]）</p><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p><p>CMD：指定一个容器启动时要运行的命令，Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>ENTRYPOINT：指定一个容器启动时要运行的命令，ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数</p><p>ONBUILD：当构建一个被继承的 Dockerfile 时运行命令，父镜像在被子继承后父镜像的 onbuild 被触发</p><h5 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h5><h6 id="Dockerfile-定制镜像"><a href="#Dockerfile-定制镜像" class="headerlink" title="Dockerfile 定制镜像"></a>Dockerfile 定制镜像</h6><p>从 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> mynginx</span><br><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> mynginx</span><br><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> Dockerfile</span><br></code></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM nginx<br>RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html<br></code></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h5 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h5><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定基础镜像，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://store.docker.com/">Docker Store</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://store.docker.com/images/nginx/"><code>nginx</code></a>、<a href="https://store.docker.com/images/redis/"><code>redis</code></a>、<a href="https://store.docker.com/images/mongo/"><code>mongo</code></a>、<a href="https://store.docker.com/images/mysql/"><code>mysql</code></a>、<a href="https://store.docker.com/images/httpd/"><code>httpd</code></a>、<a href="https://store.docker.com/images/php/"><code>php</code></a>、<a href="https://store.docker.com/images/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://store.docker.com/images/node"><code>node</code></a>、<a href="https://store.docker.com/images/openjdk/"><code>openjdk</code></a>、<a href="https://store.docker.com/images/python/"><code>python</code></a>、<a href="https://store.docker.com/images/ruby/"><code>ruby</code></a>、<a href="https://store.docker.com/images/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://store.docker.com/images/ubuntu/"><code>ubuntu</code></a>、<a href="https://store.docker.com/images/debian/"><code>debian</code></a>、<a href="https://store.docker.com/images/centos/"><code>centos</code></a>、<a href="https://store.docker.com/images/fedora/"><code>fedora</code></a>、<a href="https://store.docker.com/images/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">FROM scratch<br><span class="hljs-meta">...</span><br></code></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd"><code>coreos/etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h5 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h5><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM debian:jessie<br>RUN apt-get update<br>RUN apt-get install -y gcc libc6-dev make<br>RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;<br>RUN mkdir -p /usr/src/redis<br>RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1<br>RUN make -C /usr/src/redis<br>RUN make -C /usr/src/redis install<br></code></pre></td></tr></table></figure><p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM debian:jessie<br> <br>RUN buildDeps=&#x27;gcc libc6-dev make&#x27; \<br>    &amp;&amp; apt-get update \<br>    &amp;&amp; apt-get install -y $buildDeps \<br>    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \<br>    &amp;&amp; mkdir -p /usr/src/redis \<br>    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \<br>    &amp;&amp; make -C /usr/src/redis \<br>    &amp;&amp; make -C /usr/src/redis install \<br>    &amp;&amp; rm -rf /var/lib/apt/lists/* \<br>    &amp;&amp; rm redis.tar.gz \<br>    &amp;&amp; rm -r /usr/src/redis \<br>    &amp;&amp; apt-get purge -y --auto-remove $buildDeps<br></code></pre></td></tr></table></figure><h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><p>让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker build -t nginx:v3 .</span><br>Sending build context to Docker daemon 2.048 kB<br>Step 1 : FROM nginx<br><span class="hljs-meta"> ---&gt; </span><span class="language-bash">e43d811ce2f4</span><br>Step 2 : RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html<br><span class="hljs-meta"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 9cdc27646c7b</span><br><span class="hljs-meta"> ---&gt; </span><span class="language-bash">44aa4490ce2c</span><br>Removing intermediate container 9cdc27646c7b<br>Successfully built 44aa4490ce2c<br></code></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [选项] &lt;上下文路径/URL/-&gt;<br></code></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h5 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h5><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/engine/reference/api/docker_remote_api/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY ./package.json /app/<br></code></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 上下文（context） 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker build -t nginx:v3 .</span><br>Sending build context to Docker daemon 2.048 kB<br></code></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker镜像</title>
    <link href="/2022/03/08/docker-docker%E9%95%9C%E5%83%8F/"/>
    <url>/2022/03/08/docker-docker%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h6 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h6><p><a href="https://hub.docker.com/explore/">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]<br></code></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</li></ul><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker pull ubuntu:16.04</span><br>16.04: Pulling from library/ubuntu<br>bf5d46315322: Pull complete<br>9f13e0ac480c: Pull complete<br>e8988b5b3097: Pull complete<br>40af181810e7: Pull complete<br>e6f7c7e5c03e: Pull complete<br>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe<br>Status: Downloaded newer image for ubuntu:16.04<br></code></pre></td></tr></table></figure><h6 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h6><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span></span><br>REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE<br>flask-hello               latest              2921286533e1        17 minutes ago      924MB<br>python                    3.6                 2dfb6d103623        5 days ago          914MB<br>redis                     latest              987b78fc9e38        6 days ago          104MB<br>caijiacheng0707/hello-c   latest              eca19e80e3c4        13 days ago         861kB<br>wordpress                 latest              fd5f88e17621        2 weeks ago         541MB<br>mysql                     5.7                 f965319e89de        3 weeks ago         448MB<br>mysql                     latest              a7a67c95e831        3 weeks ago         541MB<br>nginx                     latest              602e111c06b6        4 weeks ago         127MB<br>python                    2.7-alpine          8579e446340f        4 weeks ago         71.1MB<br>arm32v7/python            2.7-slim            b532061a7f5b        4 weeks ago         107MB<br></code></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。</p><h6 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h6><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:16.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker system <span class="hljs-built_in">df</span></span><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br>Images          8         5         3.789GB   2.102GB (55%)<br>Containers      5         5         1.302GB   0B (0%)<br>Local Volumes   1         1         477B      0B (0%)<br>Build Cache     0         0         0B        0B<br></code></pre></td></tr></table></figure><h6 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h6><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;none&gt;</span>               <span class="hljs-section">&lt;none&gt;</span>              <span class="hljs-attribute">00285df0df87</span>        <span class="hljs-number">5</span> days ago          <span class="hljs-number">342</span> MB<br></code></pre></td></tr></table></figure><p>举个例子，原先有个镜像是 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> -f dangling=<span class="hljs-literal">true</span></span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB<br></code></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi $(docker images -q -f dangling=true)<br>或者<br>docker image prune<br></code></pre></td></tr></table></figure><h6 id="过滤器参数"><a href="#过滤器参数" class="headerlink" title="过滤器参数"></a>过滤器参数</h6><p><code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mysql:5.7</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">$ docker image <span class="hljs-built_in">ls</span> -f since=mysql:5.7</span><br>REPOSITORY                           TAG       IMAGE ID       CREATED        SIZE<br>127.0.0.1:5000/someprojectname_web   latest    b677af2e964b   23 hours ago   917MB<br>someprojectname_web                  latest    b677af2e964b   23 hours ago   917MB<br>redis                                7.0-rc2   72a8e4381086   4 days ago     117MB<br></code></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> -f before=mysql:5.7</span><br>REPOSITORY      TAG       IMAGE ID       CREATED        SIZE<br>python          3.7       dbd6ecf8172a   6 days ago     903MB<br>nginx           latest    c919045c4c2b   6 days ago     142MB<br>kibana          8.0.1     63dda2ae62ae   11 days ago    887MB<br>elasticsearch   8.0.1     620a7a6cd294   11 days ago    1.2GB<br>centos          latest    5d0da3dc9764   5 months ago   231MB<br></code></pre></td></tr></table></figure><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> -q</span><br>b677af2e964b<br>b677af2e964b<br>72a8e4381086<br>8b94b71dcc1e<br>dbd6ecf8172a<br>c919045c4c2b<br>63dda2ae62ae<br>620a7a6cd294<br>5d0da3dc9764<br></code></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/go-templates/">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span><br>b677af2e964b: 127.0.0.1:5000/someprojectname_web<br>b677af2e964b: someprojectname_web<br>72a8e4381086: redis<br>8b94b71dcc1e: mysql<br>dbd6ecf8172a: python<br>c919045c4c2b: nginx<br>63dda2ae62ae: kibana<br>620a7a6cd294: elasticsearch<br>5d0da3dc9764: centos<br></code></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">ls</span> --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br>IMAGE ID       REPOSITORY                           TAG<br>b677af2e964b   127.0.0.1:5000/someprojectname_web   latest<br>b677af2e964b   someprojectname_web                  latest<br>72a8e4381086   redis                                7.0-rc2<br>8b94b71dcc1e   mysql                                5.7<br>dbd6ecf8172a   python                               3.7<br>c919045c4c2b   nginx                                latest<br>63dda2ae62ae   kibana                               8.0.1<br>620a7a6cd294   elasticsearch                        8.0.1<br>5d0da3dc9764   centos                               latest<br></code></pre></td></tr></table></figure><h6 id="Docker-删除本地镜像"><a href="#Docker-删除本地镜像" class="headerlink" title="Docker 删除本地镜像"></a>Docker 删除本地镜像</h6><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></figure><h6 id="用-docker-image-ls-命令来配合删除镜像"><a href="#用-docker-image-ls-命令来配合删除镜像" class="headerlink" title="用 docker image ls 命令来配合删除镜像"></a>用 docker image ls 命令来配合删除镜像</h6><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image rm $(docker image ls -q redis)<br></code></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image rm $(docker image ls -q -f before=mongo:3.2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器</title>
    <link href="/2022/03/08/docker-docker%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/03/08/docker-docker%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="常用容器命令"><a href="#常用容器命令" class="headerlink" title="常用容器命令"></a>常用容器命令</h5><p>•列出当前所有容器：docker ps [OPTIONS]</p><p>•新建并启动容器：docker run [OPTIONS] IMAGE [COMMAND] [ARG]</p><p>•启动容器：docker start 容器ID或容器名</p><p>•重启容器：docker restart 容器ID或容器名</p><p>•停止容器：docker stop 容器ID或容器名</p><p>•删除已容器：docker rm容器ID或容器名</p><p>•查看容器日志：docker logs -f –t 容器名或容器ID</p><h5 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h5><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker run centos:latest /bin/echo <span class="hljs-string">&#x27;Hello world!&#x27;</span></span><br>Hello world!<br></code></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker run -t  -i centos:latest /bin/bash</span><br>[root@8b2983ce386d /]# <br></code></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@8b2983ce386d /]# pwd<br>/<br>[root@8b2983ce386d /]# ls<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h5 id="这三个参数-i-t-d-是啥意思"><a href="#这三个参数-i-t-d-是啥意思" class="headerlink" title="这三个参数(-i, -t, -d)是啥意思"></a>这三个参数(-i, -t, -d)是啥意思</h5><p>每次运行容器的时候都可能会遇到——“我是执行了docker run可是就是没有启动成功”，这是啥情况呢，一般都是(-i, -t, -d)这三个参数的使用问题，所以下面就详细介绍一下这-i，-t，-d都应用在什么情况下以及又应该怎么组合搭配使用</p><p>这三个参数(-i, -t, -d)是啥意思</p><ul><li>-i 以交互模式运行容器，通常与 -t 同时使用；</li><li>-t 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>-d 后台运行容器，并返回容器ID；</li></ul><p>该如何组合应用这三个参数<br>例如：”我想在后台运行一个镜像“，当我执行下方命令的时候</p><p>docker run -d –name server somebody:dockerfile</p><p>通过docker ps查看是否运行成功，却发现，没有运行成功，这是什么情况呢？？后台运行不就是运用-d参数吗？其实主要原因就是这个镜像可能最后添加了CMD就类似</p><p><code>CMD [&quot;/bin/bash&quot;]</code></p><p>意思就是当你在后台运行的时候，这个镜像创建的容器会首先执行&#x2F;bin&#x2F;bash，这意味着，当在后台运行（-d）时，shell立即退出。所以除非命令未在前台运行，否则容器会立即停止<br>解决方法</p><p>通过-i或者-t为-d提供一个伪”tty n“</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker run -i -d images:tags</span><br><span class="hljs-meta">$ </span><span class="language-bash">docker run -t -d images:tags</span><br><span class="hljs-meta">$ </span><span class="language-bash">docker run -itd images:tags</span><br></code></pre></td></tr></table></figure><h5 id="Docker-进入容器"><a href="#Docker-进入容器" class="headerlink" title="Docker 进入容器"></a>Docker 进入容器</h5><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h6 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h6><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS         PORTS                                                                                  NAMES<br>df7010b4c7b0   registry              &quot;/entrypoint.sh /etc…&quot;   37 minutes ago   Up 4 seconds   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp                                              gifted_mestorf<br>eca6fe16f811   nginx:latest          &quot;/docker-entrypoint.…&quot;   4 hours ago      Up 3 seconds   80/tcp, 0.0.0.0:4000-&gt;4000/tcp, :::4000-&gt;4000/tcp                                      someprojectname_nginx_1<br>742dba821a2a   someprojectname_web   &quot;python app.py&quot;          4 hours ago      Up 2 hours     0.0.0.0:49160-&gt;5000/tcp, :::49160-&gt;5000/tcp                                            someprojectname_web_2<br>7df8774030e1   elasticsearch:8.0.1   &quot;/bin/tini -- /usr/l…&quot;   29 hours ago     Up 6 hours     0.0.0.0:9200-&gt;9200/tcp, :::9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp, :::9300-&gt;9300/tcp   elasticsearch<br>18e3eaf1e683   redis:7.0-rc2         &quot;docker-entrypoint.s…&quot;   3 days ago       Up 6 hours     0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp                                              redis<br>d8c29e000313   mysql:5.7             &quot;docker-entrypoint.s…&quot;   3 days ago       Up 6 hours     0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp                                   mysql<br><span class="hljs-meta">$ </span><span class="language-bash">docker attac eca6fe16f811</span><br></code></pre></td></tr></table></figure><p><em>注意：</em> 如果从这个 容器中 exit，会导致容器的停止。</p><p>如果想正常退出但不关闭容器，请按 Ctrl+P+Q进行退出容器</p><h6 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h6><p>-i -t 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -dit ubuntu<br>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6<br> <br>$ docker container <span class="hljs-built_in">ls</span><br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>69d137adef7a        ubuntu:latest       <span class="hljs-string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles<br> <br>$ docker <span class="hljs-built_in">exec</span> -i 69d1 bash<br><span class="hljs-built_in">ls</span><br>bin<br>boot<br>dev<br>...<br> <br>$ docker <span class="hljs-built_in">exec</span> -it 69d1 bash<br>root@69d137adef7a:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>如果从这个 容器 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h5 id="Docker-删除容器"><a href="#Docker-删除容器" class="headerlink" title="Docker 删除容器"></a>Docker 删除容器</h5><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container <span class="hljs-built_in">rm</span>  trusting_newton<br>trusting_newton<br></code></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器</p><h5 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h5><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker container prune<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker仓库</title>
    <link href="/2022/03/08/docker-docker%E4%BB%93%E5%BA%93/"/>
    <url>/2022/03/08/docker-docker%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念。</p><h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>你可以在 <a href="https://cloud.docker.com/">https://cloud.docker.com</a> 免费注册一个 Docker 账号。</p><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker login</span><br>Login with your Docker ID to push and pull images from Docker Hub. If you don&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.<br>Username: whitechicken<br>Password: <br>WARNING! Your password will be stored unencrypted in /home/ubuntu/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded<br></code></pre></td></tr></table></figure><p>可以通过 <code>docker logout</code> 退出登录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker <span class="hljs-built_in">logout</span></span><br>Removing login credentials for https://index.docker.io/v1/<br></code></pre></td></tr></table></figure><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker search centos</span><br>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>centos                            The official build of CentOS.                   7061      [OK]       <br>centos/systemd                    systemd enabled base container.                 105                  [OK]<br>centos/mysql-57-centos7           MySQL 5.7 SQL database server                   92                   <br>centos/postgresql-96-centos7      PostgreSQL is an advanced Object-Relational …   45                   <br>centos/httpd-24-centos7           Platform for running Apache httpd 2.4 or bui…   43                   <br>centos/python-35-centos7          Platform for building and running Python 3.5…   39                   <br>centos/php-56-centos7             Platform for building and running PHP 5.6 ap…   34                   <br>centos/mysql-56-centos7           MySQL 5.6 SQL database server                   22                   <br>centos/postgresql-10-centos7      PostgreSQL is an advanced Object-Relational …   19                   <br>kasmweb/centos-7-desktop          CentOS 7 desktop for Kasm Workspaces            16                                <br></code></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p><p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p><p>根据是否是官方提供，可将镜像资源分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>kasmweb/centos-7-desktop</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 <code>kasmweb</code> 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker pull centos</span><br>Using default tag: latest<br>latest: Pulling from library/centos<br>a1d0c7532777: Pull complete <br>Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177<br>Status: Downloaded newer image for centos:latest<br>docker.io/library/centos:latest<br></code></pre></td></tr></table></figure><h5 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h5><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">~$ </span><span class="language-bash">docker commit someprojectname_web_2 whitechicken/web:latest</span><br>sha256:b34f6d640f5cd9aab3aeb0e22bcdc1606b54b598b65f25d1c9fd931cb0059e67<br><span class="hljs-meta">$ </span><span class="language-bash">docker images</span><br>REPOSITORY            TAG       IMAGE ID       CREATED         SIZE<br>whitechicken/web      latest    b34f6d640f5c   4 seconds ago   917MB<br>someprojectname_web   latest    b677af2e964b   21 hours ago    917MB<br>redis                 7.0-rc2   72a8e4381086   4 days ago      117MB<br>mysql                 5.7       8b94b71dcc1e   5 days ago      448MB<br>python                3.7       dbd6ecf8172a   6 days ago      903MB<br>nginx                 latest    c919045c4c2b   6 days ago      142MB<br>kibana                8.0.1     63dda2ae62ae   11 days ago     887MB<br>elasticsearch         8.0.1     620a7a6cd294   11 days ago     1.2GB<br>centos                latest    5d0da3dc9764   5 months ago    231MB<br><span class="hljs-meta">$ </span><span class="language-bash">docker push whitechicken/web:latest</span><br>The push refers to repository [docker.io/whitechicken/web]<br></code></pre></td></tr></table></figure><h4 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h4><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。以下内容基于 <a href="https://github.com/docker/distribution"><code>docker-registry</code></a> v2.x 版本。</p><h5 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h5><h6 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h6><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 5000:5000 --restart=always --name registry registry<br></code></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    -p 5000:5000 \<br>    -v /opt/data/registry:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><h5 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h5><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ docker images<br>REPOSITORY            TAG       IMAGE ID       CREATED          SIZE<br>whitechicken/web      latest    b34f6d640f5c  <span class="hljs-number"> 19 </span>minutes ago   917MB<br>someprojectname_web   latest    b677af2e964b  <span class="hljs-number"> 21 </span>hours ago     917MB<br>redis                 7.0-rc2   72a8e4381086  <span class="hljs-number"> 4 </span>days ago       117MB<br>mysql                 5.7       8b94b71dcc1e  <span class="hljs-number"> 5 </span>days ago       448MB<br>python                3.7       dbd6ecf8172a  <span class="hljs-number"> 6 </span>days ago       903MB<br>nginx                 latest    c919045c4c2b  <span class="hljs-number"> 6 </span>days ago       142MB<br>kibana                8.0.1     63dda2ae62ae  <span class="hljs-number"> 11 </span>days ago      887MB<br>elasticsearch         8.0.1     620a7a6cd294  <span class="hljs-number"> 11 </span>days ago      1.2GB<br>centos                latest    5d0da3dc9764  <span class="hljs-number"> 5 </span>months ago     231MB<br></code></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>someprojectname_web:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/someprojectname_web:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag someprojectname_web:latest 127.0.0.1:5000/someprojectname_web:latest<br></code></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push 127.0.0.1:5000/someprojectname_web:latest<br></code></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">curl 127.0.0.1:5000/v2/_catalog</span><br>&#123;&quot;repositories&quot;:[&quot;someprojectname_web&quot;]&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到 {“repositories”:[“someprojectname_web”]}，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">docker image <span class="hljs-built_in">rm</span> 127.0.0.1:5000/someprojectname_web:latest</span><br><span class="hljs-meta">$ </span><span class="language-bash">docker pull 127.0.0.1:5000/someprojectname_web:latest</span><br></code></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h5 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h5><h6 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h6><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">DOCKER_OPTS</span>=<span class="hljs-string">&quot;–registry-mirror=https://registry.docker-cn.com&quot;</span><br></code></pre></td></tr></table></figure><p>重新启动服务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service docker restart<br></code></pre></td></tr></table></figure><h6 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h6><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>  #非https访问<br>    <span class="hljs-string">&quot;192.168.199.100:5000&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</em></p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>对于 <code>Docker for Mac</code> 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose模板文件</title>
    <link href="/2022/03/07/docker-docker-compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"/>
    <url>/2022/03/07/docker-docker-compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">version: &quot;3&quot;<br>services:<br>  webapp:<br>    image: examples/web<br>    ports:<br>      - &quot;80:80&quot;<br>    volumes:<br>      - &quot;/data&quot;<br></code></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><p>下面分别介绍各个指令的用法。</p><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  webapp:<br>    build: ./dir<br></code></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  webapp:<br>    build:<br>      context: ./dir<br>      dockerfile: Dockerfile-alternate<br>      args:<br>        buildno: 1<br></code></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">build:<br>  context: .<br>  cache_from:<br>    - alpine:latest<br>    - corp/web_app:3.14<br></code></pre></td></tr></table></figure><h5 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h5><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ports:</span><br> - <span class="hljs-string">&quot;3000&quot;</span><br> - <span class="hljs-string">&quot;8000:8000&quot;</span><br> - <span class="hljs-string">&quot;49100:22&quot;</span><br> - <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span><br></code></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h5 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h5><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">volumes:<br> - /var/lib/mysql<br> - cache/:/tmp/cache<br> - ~/configs:/etc/configs/:ro<br></code></pre></td></tr></table></figure><h5 id="command"><a href="#command" class="headerlink" title="command"></a>command</h5><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">command: echo &quot;hello world&quot;<br></code></pre></td></tr></table></figure><h5 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h5><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">container_name: docker-web-container<br></code></pre></td></tr></table></figure><p><em>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</em></p><h5 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h5><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &quot;3.1&quot;<br>services:<br> <br>mysql:<br>  image: mysql<br>  environment:<br>    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password<br>  secrets:<br>    - db_root_password<br>    - my_other_secret<br> <br>secrets:<br>  my_secret:<br>    file: ./my_secret.txt<br>  my_other_secret:<br>    external: true<br></code></pre></td></tr></table></figure><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">entrypoint: /code/entrypoint.sh<br></code></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">user: nginx<br></code></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">working_dir: /code<br></code></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">domainname</span>: your_website.com<br><span class="hljs-attribute">hostname</span>: test<br><span class="hljs-attribute">mac_address</span>: <span class="hljs-number">08</span>-<span class="hljs-number">00</span>-<span class="hljs-number">27</span>-<span class="hljs-number">00</span>-<span class="hljs-number">0</span>C-<span class="hljs-number">0</span>A<br></code></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">privileged: <span class="hljs-literal">true</span>privileged:` `<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">restart</span>: <span class="hljs-keyword">always</span><br></code></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">read_only:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tty</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h5 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h5><p>仅用于 <code>Swarm mode</code></p><h5 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h5><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cgroup_parent:</span> cgroups_1<br></code></pre></td></tr></table></figure><h5 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h5><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cap_add:<br>  - ALL<br></code></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cap_drop:<br>  - NET_ADMIN<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose命令</title>
    <link href="/2022/03/07/docker-docker-compose%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/07/docker-docker-compose%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]<br></code></pre></td></tr></table></figure><h5 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h5><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h5 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h5><h6 id="up"><a href="#up" class="headerlink" title="up"></a>up</h6><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h6 id="build"><a href="#build" class="headerlink" title="build"></a>build</h6><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h6 id="port"><a href="#port" class="headerlink" title="port"></a>port</h6><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h6 id="down"><a href="#down" class="headerlink" title="down"></a>down</h6><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h6 id="config"><a href="#config" class="headerlink" title="config"></a>config</h6><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><p>进入指定的容器。</p><h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><p>获得一个命令的帮助。</p><h6 id="images"><a href="#images" class="headerlink" title="images"></a>images</h6><p>列出 Compose 文件中包含的镜像。</p><h6 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h6><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose ``kill` `-s SIGINT<br></code></pre></td></tr></table></figure><h6 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h6><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h6 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h6><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><h6 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h6><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h6 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h6><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h6 id="push"><a href="#push" class="headerlink" title="push"></a>push</h6><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h6 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h6><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h6 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h6><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h6 id="run"><a href="#run" class="headerlink" title="run"></a>run</h6><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose run ubuntu ping docker.com<br></code></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose run --no-deps web python manage.py<br></code></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h6 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h6><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose scale web=3 db=2<br></code></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h6 id="start"><a href="#start" class="headerlink" title="start"></a>start</h6><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h6 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h6><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h6 id="top"><a href="#top" class="headerlink" title="top"></a>top</h6><p>查看各个服务容器内运行的进程。</p><h6 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h6><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h6 id="version"><a href="#version" class="headerlink" title="version"></a>version</h6><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose使用</title>
    <link href="/2022/03/07/docker-docker-compose%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/07/docker-docker-compose%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><p>首先介绍几个术语。</p><ul><li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p><h5 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h5><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> redis <span class="hljs-keyword">import</span> Redis<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> socket<br> <br>app = Flask(__name__)<br>redis = Redis(host=os.environ.get(<span class="hljs-string">&#x27;REDIS_HOST&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>), port=<span class="hljs-number">6379</span>)<br> <br> <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    redis.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello Container World! I have been seen %s times and my hostname is %s.\n&#x27;</span> % (redis.get(<span class="hljs-string">&#x27;hits&#x27;</span>),socket.gethostname())<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=<span class="hljs-number">5000</span>, debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h5 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h5><p>编写 <code>Dockerfile</code> 文件，内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>FROM python:3.6<br>LABEL maintaner=&quot;weiming&quot;<br>COPY . /app<br>WORKDIR /app<br>RUN pip install flask redis<br>EXPOSE 5000<br>CMD [ &quot;python&quot;, &quot;app.py&quot; ]<br></code></pre></td></tr></table></figure><h5 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h5><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &quot;3&quot;<br>services:<br>  redis:<br>    image: redis<br>  web:<br>    build:<br>      context: .<br>      dockerfile: Dockerfile<br>    ports:<br>      - 5000:5000<br>    environment:<br>      REDIS_HOST: redis<br></code></pre></td></tr></table></figure><h5 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-compose简介</title>
    <link href="/2022/03/07/docker-docker-compose/"/>
    <url>/2022/03/07/docker-docker-compose/</url>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p><p>我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>linux系统命令行安装方式</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">sudo pip3 install docker-compose<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo curl -L https://github.com/docker/compose/releases/download/`curl -Ls -o /dev/null -w %&#123;url_effective&#125; https://github.com/docker/compose/releases/latest | awk -F / &#x27;&#123;print $NF&#125;&#x27;`/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br>sudo chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo` `rm` `/usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis面试总结</title>
    <link href="/2022/03/04/mybatis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/04/mybatis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h6 id="1-和-的区别"><a href="#1-和-的区别" class="headerlink" title="1.#{}和${}的区别"></a>1.#{}和${}的区别</h6><p>#{}是预编译处理，${}是字符串替换。Mybatis在处理#{}时会将sql中的#{}替换为?,PreparedStatement 的set方法来赋值；Mybatis在处理${}时会将sql中的${}替换为变量的值。使用#{}可以有效防止sql注入，提高系统安全性；</p><h6 id="2-Mybatis-Dao接口工作原理？是否可以重载？"><a href="#2-Mybatis-Dao接口工作原理？是否可以重载？" class="headerlink" title="2.Mybatis Dao接口工作原理？是否可以重载？"></a>2.Mybatis Dao接口工作原理？是否可以重载？</h6><p>Dao 接口，就是人们常说的Mapper 接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement 的id值，接口方法内的参数，就是传递给sql 的参数。Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key 值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace 为com.mybatis3.mappers.StudentDao 下面id &#x3D; findStudentById 的MappedStatement。在Mybatis 中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement 对象。Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。Dao 接口的工作原理是JDK 动态代理，Mybatis 运行时会使用JDK 动态代理为Dao接口生成代理proxy 对象， 代理对象proxy 会拦截接口方法， 转而执行MappedStatement 所代表的sql，然后将sql 执行结果返回。</p><h6 id="3-Mybatis分页查询？插件分页原理？"><a href="#3-Mybatis分页查询？插件分页原理？" class="headerlink" title="3.Mybatis分页查询？插件分页原理？"></a>3.Mybatis分页查询？插件分页原理？</h6><p>Mybatis 使用RowBounds 对象进行分页，它是针对ResultSet 结果集执行的内存分页，而非物理分页，可以在sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h6 id="4-Mybatis-是如何将sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#4-Mybatis-是如何将sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="4.Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>4.Mybatis 是如何将sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h6><p>第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql 列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h6 id="5-Xml-映射文件中，除了常见的select-insert-update-delete-标签之外，还有哪些标签？"><a href="#5-Xml-映射文件中，除了常见的select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="5.Xml 映射文件中，除了常见的select|insert|update|delete 标签之外，还有哪些标签？"></a>5.Xml 映射文件中，除了常见的select|insert|update|delete 标签之外，还有哪些标签？</h6><p>还有很多其他的标签， 加上动态sql 的9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，&lt;sql&gt;其中为sql 片段标签，通过&lt;include&gt;标签引入sql 片段，&lt;selectKey&gt;为不支持自增的主键生成策略标签。</p><h6 id="6-简述Mybatis-的插件运行原理，以及如何编写一个插件"><a href="#6-简述Mybatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="6.简述Mybatis 的插件运行原理，以及如何编写一个插件"></a>6.简述Mybatis 的插件运行原理，以及如何编写一个插件</h6><p>Mybatis 仅可以编写针对ParameterHandler 、ResultSetHandler 、StatementHandler、Executor 这4 种接口的插件，Mybatis 使用JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4 种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler 的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis 的Interceptor 接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，还需要在配置文件中配置你编写的插件。</p><h6 id="7-一级、二级缓存"><a href="#7-一级、二级缓存" class="headerlink" title="7.一级、二级缓存"></a>7.一级、二级缓存</h6><ol><li>一级缓存: 基于PerpetualCache 的HashMap 本地缓存， 其存储作用域为Session，当Session flush 或close 之后，该Session 中的所有Cache 就将清空。</li><li>二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache，HashMap 存储， 不同在于其存储作用域为Mapper(Namespace)， 并且可自定义存储源， 如Ehcache。要开启二级缓存，你需要在你的SQL 映射文件中添加一行：&#x2F;<cache/></li><li>对于缓存数据更新机制， 当某一个作用域( 一级缓存Session&#x2F; 二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有select 中的缓存将被clear。</li></ol><h6 id="8-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8.Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8.Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h6><p>Mybatis 仅支持association 关联对象和collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调<br>用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。</p><h6 id="9-Mybatis-映射文件中，如果A-标签通过include-引用了B-标签的内容，请问，B-标签能否定义在A-标签的后面，还是说必须定义在A-标签的前面？"><a href="#9-Mybatis-映射文件中，如果A-标签通过include-引用了B-标签的内容，请问，B-标签能否定义在A-标签的后面，还是说必须定义在A-标签的前面？" class="headerlink" title="9.Mybatis 映射文件中，如果A 标签通过include 引用了B 标签的内容，请问，B 标签能否定义在A 标签的后面，还是说必须定义在A 标签的前面？"></a>9.Mybatis 映射文件中，如果A 标签通过include 引用了B 标签的内容，请问，B 标签能否定义在A 标签的后面，还是说必须定义在A 标签的前面？</h6><p>虽然Mybatis 解析Xml 映射文件是按照顺序解析的，但是，被引用的B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。原理是，Mybatis 解析A 标签，发现A 标签引用了B 标签，但是B 标签尚未解析到，尚不存在，此时，Mybatis 会将A 标签标记为未解析状态，然后继续解析余下的标签，包含B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h6 id="10-简述Mybatis-的Xml-映射文件和Mybatis-内部数据结构之间的映射关系？"><a href="#10-简述Mybatis-的Xml-映射文件和Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="10.简述Mybatis 的Xml 映射文件和Mybatis 内部数据结构之间的映射关系？"></a>10.简述Mybatis 的Xml 映射文件和Mybatis 内部数据结构之间的映射关系？</h6><p>Mybatis 将所有Xml 配置信息都封装到All-In-One 重量级对象Configuration 内部。在Xml 映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap 对象，其每个子元素会被解析为ParameterMapping 对象。&lt;resultMap&gt;标签会被解析为ResultMap 对象，其每个子元素会被解析为ResultMapping 对象。每一&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement 对象，标签内的sql 会被解析为BoundSql 对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>延时消息</title>
    <link href="/2022/03/01/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/"/>
    <url>/2022/03/01/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>延时消息（定时消息）是指在异步场景下，生产者发送的消息不希望被消费者马上消费，而是在延时或在指定时间消费。延时消费场景应用比较广泛，如计算电商订单是否支付、活动时间内任务是否完成。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="基于外部存储实现的方案"><a href="#基于外部存储实现的方案" class="headerlink" title="基于外部存储实现的方案"></a>基于外部存储实现的方案</h3><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">外部存储指的是在MQ本身自带的存储以外又引入的其他存储系统。</span><br></code></pre></td></tr></table></figure><p>基于外部存储的方案实际都是一样的套路，将MQ和延时模块区分开来，延时消息模块是一个独立的服务&#x2F;进程。消息先保存在其他存储介质，等消息到期在投递到MQ。当消息进入延时模块已经到期，则直接投递。</p><img src="/2022/03/01/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0.png" class=""><h4 id="基于数据库（如MySQL）"><a href="#基于数据库（如MySQL）" class="headerlink" title="基于数据库（如MySQL）"></a>基于数据库（如MySQL）</h4><p>基于关系型数据库（如MySQL）延时消息表的方式来实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `delay_msg` (<br>  `id` <span class="hljs-type">bigint</span> unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `delivery_time` DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;投递时间&#x27;</span>,<br>  `payloads` <span class="hljs-type">blob</span> COMMENT <span class="hljs-string">&#x27;消息内容&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `time_index` (`delivery_time`)<br>)<br></code></pre></td></tr></table></figure><p>通过定时线程定时扫描到期的消息，然后进行投递。定时线程的扫描间隔理论上就是你延时消息的最小时间精度。</p><p>优点：</p><ul><li>实现简单；</li></ul><p>缺点：</p><ul><li>B+Tree索引不适合消息场景的大量写入；</li></ul><h4 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h4><img src="/2022/03/01/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/Redis%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0.png" class=""><ul><li>Messages Pool 所有的延时消息存放，结构为KV结构，key为消息ID，value为一个具体的message（这里选择Redis Hash结构主要是因为hash结构能存储较大的数据量，数据较多时候会进行渐进式rehash扩容，并且对于HSET和HGET命令来说时间复杂度都是O(1)）</li><li>Delayed Queue是16个有序队列（队列支持水平扩展），结构为ZSET，value 为 messages pool中消息ID，score为过期时间（<strong>分为多个队列是为了提高扫描的速度）</strong></li><li>Worker 代表处理线程，通过定时任务扫描 Delayed Queue 中到期的消息</li></ul><p>这个方案选用 Redis 存储在我看来有几点考虑。</p><ul><li>Redis ZSET 很适合实现延时队列</li><li>性能问题，虽然 ZSET 插入是一个 O(logn) 的操作，但是Redis 基于内存操作，并且内部做了很多性能方面的优化。</li></ul><p>但是这个方案其实也有需要斟酌的地方，上述方案通过创建多个 Delayed Queue 来满足对于并发性能的要求，但这也带来了多个 Delayed Queue 如何在多个节点情况下均匀分配，并且很可能出现到期消息并发重复处理的情况，是否要引入分布式锁之类的并发控制设计？</p><p>在量不大的场景下，上述方案的架构其实可以蜕化成主从架构，只允许主节点来处理任务，从节点只做容灾备份。实现难度更低更可控。</p><h4 id="定时线程检查的缺陷与改进"><a href="#定时线程检查的缺陷与改进" class="headerlink" title="定时线程检查的缺陷与改进"></a>定时线程检查的缺陷与改进</h4><p>上述几个方案中，都通过线程定时扫描的方案来获取到期的消息。</p><p>定时线程的方案在消息量较少的时候，会浪费资源，在消息量非常多的时候，又会出现因为扫描间隔设置不合理导致延时时间不准确的问题。可以借助 JDK Timer 类中的思想，通过 wait-notify 来节省 CPU 资源。</p><p>获取中最近的延时消息，然后wait(执行时间-当前时间)，这样就不需要浪费资源到达时间时会自动响应，如果有新的消息进入，并且比我们等待的消息还要小，那么直接notify唤醒，重新获取这个更小的消息，然后又wait，如此循环。</p><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ 开源版本支持延时消息，但是只支持 18 个 Level 的延时，并不支持任意时间。只不过这个 Level 在 RocketMQ 中可以自定义的，所幸来说对普通业务算是够用的。默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。</p><p>通俗的讲，设定了延时 Level 的消息会被暂存在名为 <code>SCHEDULE_TOPIC_XXXX</code>的topic中，并根据 level 存入特定的queue，queueId &#x3D; delayTimeLevel – 1，<font color='red'><strong>即一个queue只存相同延时的消息，保证具有相同发送延时的消息能够顺序消费。</strong></font>broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>优点：</p><ul><li>Level 数固定，每个 Level 有自己的定时器，开销不大</li><li>将 Level 相同的消息放入到同一个 Queue 中，保证了同一 Level 消息的顺序性；不同 Level 放到不同的 Queue 中，保证了投递的时间准确性；</li><li>通过只支持固定的Level，将不同延时消息的排序变成了固定Level Topic 的追加写操作</li></ul><p>缺点：</p><ul><li>Level 配置的修改代价太大，固定 Level 不灵活</li><li>CommitLog 会因为延时消息的存在变得很大</li></ul><h3 id="QMQ"><a href="#QMQ" class="headerlink" title="QMQ"></a>QMQ</h3><p>QMQ提供任意时间的延时&#x2F;定时消息，你可以指定消息在未来两年内(可配置)任意时间内投递。</p><p> QMQ 是目前开源 MQ 中延时消息设计最合理的。里面设计的核心简单来说就是 <strong>多级时间轮 + 延时加载 + 延时消息单独磁盘存储</strong>。</p><p>QMQ的延时&#x2F;定时消息使用的是两层 hash wheel 来实现的。</p><p>第一层位于磁盘上，每个小时为一个刻度(默认为一个小时一个刻度，可以根据实际情况在配置里进行调整)，每个刻度会生成一个日志文件(schedule log)，因为QMQ支持两年内的延时消息(默认支持两年内，可以进行配置修改)，则最多会生成 2 * 366 * 24 &#x3D; 17568 个文件(如果需要支持的最大延时时间更短，则生成的文件更少)。</p><p>第二层在内存中，当消息的投递时间即将到来的时候，会将这个小时的消息索引(索引包括消息在schedule log中的offset和size)从磁盘文件加载到内存中的hash wheel上，内存中的hash wheel则是以500ms为一个刻度。</p><img src="/2022/03/01/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/640.jfif" class=""><p>总结一下设计上的亮点：</p><ul><li>时间轮算法适合延时&#x2F;定时消息的场景，省去延时消息的排序，插入删除操作都是 O(1) 的时间复杂度；</li><li>通过多级时间轮设计，支持了超大时间跨度的延时消息；</li><li>通过延时加载，内存中只会有最近要消费的消息，更久的延时消息会被存储在磁盘中，对内存友好；</li><li>延时消息单独存储（schedule log），不会影响到正常消息的空间回收；</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li><p>死信队列。实际就是利用一个没有消费者的Queue1，等待消息过期后，通过交换机转发到Queue2来进行消费，消息的延迟时间就是消息在Queue1中的存活时间。局限性：延迟消息的延迟时间是依赖于Queue1的x-message-ttl的，也就是说，需要支持多少种延迟的时间，就得提前设置好多少个无消费类的Queue，而且由于转发绑定的Queue2需要配到交换机中，比较死板，而真实的业务中消费类肯定是不一样的。</p></li><li><p>插件实现。在rabbitmq 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。在需要发送延迟消息队列的项目中，声明一个x-delayed-message类型的交换机来使用delayed-messaging特性，注意这个交换机并不是rabbitmq本身的，而是插件提供的，一定要是x-delayed-message类型，绑定的queue就是正常的queue即可，不需要额外多余的queue(这是和不用插件方式的最大区别及好处)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
